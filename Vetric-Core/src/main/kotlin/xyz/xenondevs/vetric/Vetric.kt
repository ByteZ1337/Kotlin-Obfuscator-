package xyz.xenondevs.vetric

import xyz.xenondevs.bytebase.jvm.JavaArchive
import xyz.xenondevs.bytebase.jvm.VirtualClassPath
import xyz.xenondevs.vetric.config.VetricConfig
import xyz.xenondevs.vetric.jvm.Library
import xyz.xenondevs.vetric.logging.Logger
import xyz.xenondevs.vetric.logging.info

object Vetric {
    @Volatile
    var exit = false
    
    const val VERSION = "0.0.1"
    var debug = false
    
    var logger: Logger? = null
    
    fun run(config: VetricConfig) {
        val jar = loadJars(config)
        applyTransformers(jar, config)
        saveOutput(jar, config)
    }
    
    private fun loadJars(config: VetricConfig): JavaArchive {
        val jar = JavaArchive(config.input)
        val libraries = config.libraries
        VirtualClassPath.loadJarWithDependencies(jar, libraries)
        return jar
    }
    
    private fun applyTransformers(jar: JavaArchive, config: VetricConfig) {
        info("Loading transformer configs...")
        config.transformers.forEach { transformer ->
            transformer.loadConfig(config[transformer])
            transformer.prepare(jar)
        }
        // Second loop to properly obfuscate any methods generated by Transformer#prepare
        config.transformers.forEach { transformer ->
            info("Applying " + transformer.name + "...")
            transformer.transform(jar)
        }
    }
    
    private fun saveOutput(jar: JavaArchive, config: VetricConfig) {
        info("Saving jar...")
        config.libraries.filter(Library::isExtracted).forEach { it.extractInto(jar) }
        jar.writeFile(config.output)
    }
    
}